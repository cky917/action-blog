(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{231:function(t,_,a){"use strict";a.r(_);var v=a(2),e=Object(v.a)({},(function(){var t=this,_=t.$createElement,a=t._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("Node.js最大的特性就是"),a("strong",[t._v("异步式IO")]),t._v("与"),a("strong",[t._v("事件")]),t._v("紧密结合的编程模式，这种模式与传统的同步式I/O线性的编程思路有很大的不同，因为控制流很大程度上靠事件和回调函数来组织。")]),t._v(" "),a("h3",{attrs:{id:"阻塞与线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#阻塞与线程"}},[t._v("#")]),t._v(" 阻塞与线程")]),t._v(" "),a("h4",{attrs:{id:"_1-同步式i-o-阻塞式i-o-："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-同步式i-o-阻塞式i-o-："}},[t._v("#")]),t._v(" 1.同步式I/O(阻塞式I/O)：")]),t._v(" "),a("p",[t._v("线程在执行过程中如果遇到磁盘读写或网络通信，通常要耗费较长的时间。这时操作系统会剥夺这个线程的CPU控制权，使其暂停执行，同时将资源让给其他的工作线程，这种线程调度方式称为阻塞。当I/O操作完毕时，操作系统将这个线程的阻塞状态解除，恢复其对CPU的控制权，令其继续执行。")]),t._v(" "),a("h4",{attrs:{id:"_2-异步式i-o-非阻塞式i-o"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-异步式i-o-非阻塞式i-o"}},[t._v("#")]),t._v(" 2. 异步式I/O(非阻塞式I/O)")]),t._v(" "),a("p",[t._v("针对所有的I/O操作不采用阻塞策略，当线程遇到I/O操作时，不会以阻塞的方式等待I/O操作的完成或数据的返回，而只是将I/O请求发给操作系统，继续执行下一句语句，当操作系统完成I/O操作时，以事件的形式通知执行I/O操作的线程，线程会在特定时候处理这个事件。为了处理异步I/O，线程必须有事件循环，不断地检查有没有未处理的事件，依次予以处理。")]),t._v(" "),a("h4",{attrs:{id:"_3-非阻塞与阻塞模式的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-非阻塞与阻塞模式的区别"}},[t._v("#")]),t._v(" 3.非阻塞与阻塞模式的区别")]),t._v(" "),a("p",[t._v("非阻塞模式下，一个线程永远在执行计算操作，这个线程所使用的CPU核心利用率永远是100%，I/O以事件的方式通知。\n阻塞模式下，多线程往往能提高系统的吞吐量，因为一个线程阻塞还有其他线程在工作，多线程可以让CPU资源不被阻塞中的线程浪费。")]),t._v(" "),a("h4",{attrs:{id:"_4-同步式i-o与异步式i-o区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-同步式i-o与异步式i-o区别"}},[t._v("#")]),t._v(" 4. 同步式I/O与异步式I/O区别")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("同步式I/O(阻塞式)")]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[t._v("异步式I/O(非阻塞)")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("利用多线程提供吞吐量")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("单线程即可实现高吞吐量")])]),t._v(" "),a("tr",[a("td",[t._v("通过事件片分隔和线程调度利用多核CPU")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("通过功能划分利用多核")])]),t._v(" "),a("tr",[a("td",[t._v("需要由操作系统调度多线程使用多核CPU")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("可以将单线程绑定到单核CPU")])]),t._v(" "),a("tr",[a("td",[t._v("难以充分利用CPU资源")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("可以充分利用CPU资源")])]),t._v(" "),a("tr",[a("td",[t._v("内存轨迹大，数据局部性弱")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("内存轨迹小，数据局部性强")])]),t._v(" "),a("tr",[a("td",[t._v("符合线性的编程思维")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("不符合传统编程思维")])])])])])}),[],!1,null,null,null);_.default=e.exports}}]);